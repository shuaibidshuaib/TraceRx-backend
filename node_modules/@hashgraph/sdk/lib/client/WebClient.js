import t from"./Client.js";import e from"../channel/WebChannel.js";import r from"../LedgerId.js";import{WEB_PREVIEWNET as s,MirrorNetwork as o,WEB_TESTNET as n,MAINNET as i}from"../constants/ClientConstants.js";import a from"../network/AddressBookQueryWeb.js";import w from"../file/FileId.js";const k={MAINNET:i,TESTNET:n,PREVIEWNET:s};class N extends t{constructor(e){if(super(e),null!=e)if("string"==typeof e.network)switch(e.network){case"mainnet":this.setNetwork(k.MAINNET),this.setMirrorNetwork(o.MAINNET),this.setLedgerId(r.MAINNET);break;case"testnet":this.setNetwork(k.TESTNET),this.setLedgerId(r.TESTNET),this.setMirrorNetwork(o.TESTNET);break;case"previewnet":this.setNetwork(k.PREVIEWNET),this.setLedgerId(r.PREVIEWNET),this.setMirrorNetwork(o.PREVIEWNET);break;default:throw new Error(`unknown network: ${e.network}`)}else if(null!=e.network){t._validateNetworkConsistency(e.network);const{shard:r,realm:s}=t._extractShardRealm(e.network);this._shard=r,this._realm=s,this.setNetwork(e.network)}}static fromConfig(t){return new N("string"==typeof t?JSON.parse(t):t)}static forNetwork(t){return new N({network:t})}static forName(t){return new N({network:t})}static forMainnet(){return new N({network:"mainnet"})}static forTestnet(){return new N({network:"testnet"})}static forPreviewnet(){return new N({network:"previewnet"})}static async forMirrorNetwork(t){const e=new N;return e.setMirrorNetwork(t),await e.updateNetwork(),e}setNetwork(t){if("string"==typeof t)switch(t){case"previewnet":this._network.setNetwork(k.PREVIEWNET);break;case"testnet":this._network.setNetwork(k.TESTNET);break;case"mainnet":this._network.setNetwork(k.MAINNET)}else this._network.setNetwork(t)}setMirrorNetwork(t){if("string"==typeof t)switch(t){case"local-node":this._mirrorNetwork.setNetwork(o.LOCAL_NODE);break;case"previewnet":this._mirrorNetwork.setNetwork(o.PREVIEWNET);break;case"testnet":this._mirrorNetwork.setNetwork(o.TESTNET);break;case"mainnet":this._mirrorNetwork.setNetwork(o.MAINNET);break;default:this._mirrorNetwork.setNetwork([t])}else this._mirrorNetwork.setNetwork(t);return this}async updateNetwork(){if(!this._isUpdatingNetwork){this._isUpdatingNetwork=!0;try{const t=await(new a).setFileId(w.getAddressBookFileIdFor(this.shard,this.realm)).execute(this),e={};for(const r of t.nodeAddresses)for(const t of r.addresses)null!=r.accountId&&(e[t.toString()]=r.accountId);this.setNetwork(e)}catch(t){if(this._logger){const e=t instanceof Error?t.message:String(t);this._logger.trace(`failed to update client address book: ${e}`)}}finally{this._isUpdatingNetwork=!1}}}_createNetworkChannel(){return t=>new e(t)}_createMirrorNetworkChannel(){return()=>{throw new Error("mirror support is not supported in browsers")}}}export{k as Network,N as default};
//# sourceMappingURL=WebClient.js.map
